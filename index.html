<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Modele na sprzedaż</title>
  <style>
    table {
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px 12px;
    }
    th {
      background-color: #f5f5f5;
    }
  </style>
</head>
<body>
  <h1>Modele na sprzedaż - (kolumna K = "Tak")</h1>
  
  <div id="table-container"></div>
  
  <script>
    // Nowy link do pliku jako strona HTML (pubhtml)
    const sheetHtmlUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTntplgD3H3MoafVFReoBHcC_p2gYC7zYsqbuKbBncSDAg4YLG92e72QVdvwWvx6JDZHosRtS-uD144/pubhtml?gid=1713753991&single=true';

    // Kolumna K to indeks 10 (A=0, B=1, C=2, ..., K=10)
    const COLUMN_K_INDEX = 10;
    // Szukamy dokładnie "Tak" (niezależnie od wielkości liter)
    const VALUE_TO_MATCH = 'tak';

    // Kolumny, które chcemy ukryć (lub nie wyświetlać w ogóle)
    const HIDDEN_COLUMNS = [2, 8, 9]; // C, I, J
    // Nie wyświetlamy nic powyżej kolumny o indeksie 13 (N)
    const MAX_COLUMN_INDEX = 13;

    fetch(sheetHtmlUrl)
      .then(response => response.text())
      .then(htmlString => {
        // (1) Parsujemy całą stronę HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlString, 'text/html');

        // (2) Wyszukujemy oryginalną tabelę w dokumencie
        const originalTable = doc.querySelector('table');
        if (!originalTable) {
          throw new Error('Nie znaleziono tabeli w pobranym dokumencie.');
        }

        // (3) Wyciągamy thead (nagłówki)
        const thead = originalTable.querySelector('thead');
        // Wyciągamy wiersze z body
        const rows = originalTable.querySelectorAll('tbody tr');

        // (4) Przefiltrowanie wierszy pod kątem kolumny K == "Tak"
        const filteredRows = [];
        rows.forEach(tr => {
          const cells = tr.querySelectorAll('td');
          if (cells.length > COLUMN_K_INDEX) {
            const cellValue = cells[COLUMN_K_INDEX].innerText.trim().toLowerCase();
            if (cellValue === VALUE_TO_MATCH) {
              filteredRows.push(tr);
            }
          }
        });

        // (5) Budujemy nową tabelę
        const newTable = document.createElement('table');

        // ===== Obsługa thead (nagłówki) =====
        if (thead) {
          // Sklonuj oryginalny thead
          const clonedThead = thead.cloneNode(true);
          // Ukryj niechciane kolumny w thead
          const headerRow = clonedThead.querySelector('tr');
          if (headerRow) {
            const headerCells = headerRow.querySelectorAll('th');
            // Idziemy od końca, by usuwać poprawnie (lub ukrywać)
            for (let i = headerCells.length - 1; i >= 0; i--) {
              if (i > MAX_COLUMN_INDEX || HIDDEN_COLUMNS.includes(i)) {
                headerRow.removeChild(headerCells[i]);
              }
            }
          }
          newTable.appendChild(clonedThead);
        }

        // ===== Obsługa tbody (filtr + ukrywanie kolumn) =====
        const newTbody = document.createElement('tbody');

        filteredRows.forEach(oldRow => {
          // Klonujemy wiersz
          const newRow = oldRow.cloneNode(true);
          const newCells = newRow.querySelectorAll('td');
          
          // Ukrywamy/ usuwamy niechciane kolumny
          for (let i = newCells.length - 1; i >= 0; i--) {
            if (i > MAX_COLUMN_INDEX || HIDDEN_COLUMNS.includes(i)) {
              newRow.removeChild(newCells[i]);
            }
          }

          // Dodajemy przefiltrowany i przycięty wiersz do newTbody
          newTbody.appendChild(newRow);
        });
        
        newTable.appendChild(newTbody);
        
        // (6) Dodajemy gotową tabelę do strony
        document.getElementById('table-container').appendChild(newTable);
      })
      .catch(err => {
        console.error('Błąd przy pobieraniu/parowaniu HTML:', err);
      });
  </script>
</body>
</html>
