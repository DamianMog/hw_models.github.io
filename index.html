<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Modele na sprzedaż</title>
  <style>
    table {
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px 12px;
    }
    th {
      background-color: #f5f5f5;
    }
  </style>
</head>
<body>
  <h1>Modele na sprzedaż (kolumna K = "Tak")</h1>
  
  <div id="table-container"></div>
  
  <script>
    const sheetHtmlUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTntplgD3H3MoafVFReoBHcC_p2gYC7zYsqbuKbBncSDAg4YLG92e72QVdvwWvx6JDZHosRtS-uD144/pubhtml?gid=1713753991&single=true';

    // Konfiguracja
    const COLUMN_K_INDEX = 10;         // K = 10
    const VALUE_TO_MATCH = 'tak';      // filtr na kolumnę K
    const HIDDEN_COLUMNS = [2, 8, 9];  // ukrywamy C(2), I(8), J(9)
    const MAX_COLUMN_INDEX = 13;       // powyżej N (13) usuwamy

    fetch(sheetHtmlUrl)
      .then(response => response.text())
      .then(htmlString => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlString, 'text/html');
        
        // Znajdź wszystkie tabele opublikowane przez Google
        const tables = doc.querySelectorAll('table');
        console.log('Znalezione tabele:', tables);

        // Przykład: używamy OSTATNIEJ tabeli
        // (Często tam są właściwe dane, ale zależy od układu – sprawdź w swojej publikacji)
        const originalTable = tables[tables.length - 1];
        if (!originalTable) {
          throw new Error('Nie znaleziono docelowej tabeli z danymi.');
        }

        // Spróbujmy odczytać thead
        let thead = originalTable.querySelector('thead');
        let tbody = originalTable.querySelector('tbody');

        // Jeśli thead nie istnieje lub jest pusty w th, to załóżmy, że
        // pierwszy wiersz tbody to wiersz nagłówkowy.
        if (!thead || thead.querySelectorAll('th').length === 0) {
          thead = document.createElement('thead');
          const firstRow = tbody.querySelector('tr');
          if (!firstRow) {
            throw new Error('Brak wierszy w tabeli!');
          }
          // Stwórz nowy wiersz nagłówkowy z komórek td → th
          const newHeaderRow = document.createElement('tr');
          const cells = firstRow.querySelectorAll('td');

          cells.forEach(td => {
            const th = document.createElement('th');
            th.innerText = td.innerText;
            newHeaderRow.appendChild(th);
          });

          // Dodaj nowy wiersz do thead
          thead.appendChild(newHeaderRow);

          // Usuń pierwszy wiersz z tbody, by się nie powtórzył w danych
          tbody.removeChild(firstRow);
        }

        // Teraz mamy pewność, że thead zawiera nagłówki
        // a w tbody są dane

        // Filtrujemy wiersze na "kolumna K = Tak"
        const filteredRows = [];
        const allRows = tbody.querySelectorAll('tr');
        allRows.forEach(tr => {
          const cells = tr.querySelectorAll('td');
          if (cells.length > COLUMN_K_INDEX) {
            const val = cells[COLUMN_K_INDEX].innerText.trim().toLowerCase();
            if (val === VALUE_TO_MATCH) {
              filteredRows.push(tr);
            }
          }
        });

        // Tworzymy nową tabelę
        const newTable = document.createElement('table');

        // 1) Klonujemy thead (już z prawidłowym wierszem nagłówkowym)
        const clonedThead = thead.cloneNode(true);

        // --- USUWANIE/UKRYWANIE KOLUMN W NAGŁÓWKU ---
        const headerRow = clonedThead.querySelector('tr');
        if (headerRow) {
          const headerCells = headerRow.querySelectorAll('th');
          // Przechodzimy od końca, by usuwać poprawnie
          for (let i = headerCells.length - 1; i >= 0; i--) {
            if (i > MAX_COLUMN_INDEX || HIDDEN_COLUMNS.includes(i)) {
              headerRow.removeChild(headerCells[i]);
            }
          }
        }

        newTable.appendChild(clonedThead);

        // 2) Tworzymy tbody z przefiltrowanymi wierszami
        const newTbody = document.createElement('tbody');
        filteredRows.forEach(oldRow => {
          const rowClone = oldRow.cloneNode(true);
          const cells = rowClone.querySelectorAll('td');
          
          // usuwamy/ukrywamy kolumny C(2), I(8), J(9), > N(13)
          for (let i = cells.length - 1; i >= 0; i--) {
            if (i > MAX_COLUMN_INDEX || HIDDEN_COLUMNS.includes(i)) {
              rowClone.removeChild(cells[i]);
            }
          }
          newTbody.appendChild(rowClone);
        });
        newTable.appendChild(newTbody);

        // Wstawiamy tabelę na stronę
        document.getElementById('table-container').appendChild(newTable);
      })
      .catch(err => console.error('Błąd przy pobieraniu/parowaniu HTML:', err));
  </script>
</body>
</html>
