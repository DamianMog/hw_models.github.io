<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Modele na sprzedaż</title>
  <style>
    table {
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px 12px;
    }
    th {
      background-color: #f5f5f5;
    }
  </style>
</head>
<body>
  <h1>Modele na sprzedaż (kolumna K = "Tak")</h1>
  
  <div id="table-container"></div>
  
  <script>
    // Link do opublikowanej strony HTML z Google Sheets
    const sheetHtmlUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTntplgD3H3MoafVFReoBHcC_p2gYC7zYsqbuKbBncSDAg4YLG92e72QVdvwWvx6JDZHosRtS-uD144/pubhtml?gid=1713753991&single=true';

    // Kolumna K (A=0, B=1, C=2, ..., K=10)
    const COLUMN_K_INDEX = 10;   
    const VALUE_TO_MATCH = 'tak'; // "tak" (bez względu na wielkość liter)

    // Kolumny do ukrycia
    const HIDDEN_COLUMNS = [2, 8, 9];  // C(2), I(8), J(9)
    // Maksymalny indeks kolumny, który chcemy pokazać (N = 13)
    const MAX_COLUMN_INDEX = 13;

    fetch(sheetHtmlUrl)
      .then(response => response.text())
      .then(htmlString => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlString, 'text/html');
        
        // Znajdź wszystkie tabele
        const tables = doc.querySelectorAll('table');
        console.log('Znalezione tabele:', tables);

        // Wybierz właściwą tabelę (często ostatnia w dokumencie):
        const originalTable = tables[tables.length - 1];
        if (!originalTable) {
          throw new Error('Nie znaleziono tabeli z danymi.');
        }

        // Pobierz <thead> i <tbody>
        let thead = originalTable.querySelector('thead');
        let tbody = originalTable.querySelector('tbody');

        // Jeśli thead istnieje, sprawdź, czy rzeczywiście zawiera TH z danymi
        const thInThead = thead ? thead.querySelectorAll('th') : null;
        const hasValidHeaders = thInThead && thInThead.length > 0;

        // Jeżeli thead jest pusty lub nie istnieje, a wiersz nagłówkowy (z <th>) jest w tbody:
        if (!hasValidHeaders) {
          // Szukamy pierwszego wiersza w TBODY, który ma <th> (to najpewniej nasz nagłówek)
          const headerRowInTbody = tbody.querySelector('tr th')?.closest('tr');
          if (headerRowInTbody) {
            // Jeśli thead nie istnieje, stwórzmy go
            if (!thead) {
              thead = document.createElement('thead');
              // Wstawiamy nowy thead przed tbody w strukturze oryginalnej tabeli
              originalTable.insertBefore(thead, tbody);
            }
            // Przenosimy wiersz z TBODY -> THEAD
            tbody.removeChild(headerRowInTbody);
            thead.appendChild(headerRowInTbody);
          }
        }

        // Teraz thead powinien mieć w sobie wiersz nagłówków
        // Wiersze danych powinny pozostać w tbody
        const allRows = tbody.querySelectorAll('tr');

        // --- FILTR: Kolumna K == "Tak" ---
        // Zbierzmy te wiersze, które spełniają warunek
        const filteredRows = [];
        allRows.forEach(tr => {
          const cells = tr.querySelectorAll('td');
          if (cells.length > COLUMN_K_INDEX) {
            const val = cells[COLUMN_K_INDEX].innerText.trim().toLowerCase();
            if (val === VALUE_TO_MATCH) {
              filteredRows.push(tr);
            }
          }
        });

        // ===== Budujemy nową tabelę =====
        const newTable = document.createElement('table');

        // 1) Klonujemy thead (już z poprawnym nagłówkiem?)
        const clonedThead = thead.cloneNode(true);

        // Usuwamy niechciane kolumny w thead (np. C, I, J oraz > N)
        const headerRow = clonedThead.querySelector('tr');
        if (headerRow) {
          const headerCells = headerRow.querySelectorAll('th');
          for (let i = headerCells.length - 1; i >= 0; i--) {
            if (i > MAX_COLUMN_INDEX || HIDDEN_COLUMNS.includes(i)) {
              headerRow.removeChild(headerCells[i]);
            }
          }
        }

        newTable.appendChild(clonedThead);

        // 2) Tworzymy nowe <tbody> z przefiltrowanymi wierszami
        const newTbody = document.createElement('tbody');
        filteredRows.forEach(oldRow => {
          const rowClone = oldRow.cloneNode(true);
          const cells = rowClone.querySelectorAll('td');

          // Usuwamy kolumny C(2), I(8), J(9) i wszystko powyżej N(13)
          for (let i = cells.length - 1; i >= 0; i--) {
            if (i > MAX_COLUMN_INDEX || HIDDEN_COLUMNS.includes(i)) {
              rowClone.removeChild(cells[i]);
            }
          }
          newTbody.appendChild(rowClone);
        });
        newTable.appendChild(newTbody);

        // Wyświetlamy nową tabelę
        document.getElementById('table-container').appendChild(newTable);
      })
      .catch(err => console.error('Błąd przy pobieraniu/parowaniu HTML:', err));
  </script>
</body>
</html>
